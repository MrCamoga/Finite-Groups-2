from functools import reduce
from sympy import isprime, gcd, lcm, factorint
from operator import itemgetter
from random import randint


"""
TODO:


isNormal                                                                        ✓
Inn(G)                                                                          ✓
conjugacy class                                                                 ✓
Z(G)                                                                            ✓
centralizer                                                                     ✓
left/right cosets                                                               ✓
quotient group                                                                  ✓
powers of an element                                                            ✓
symmetric group                                                                 ✓
alternating group                                                               ✓
normalizer                                                                      ✓
commutator [g,h] = g-1h-1gh                                                     ✓
false witnesses group                                                           ✓
conjugacy classes                                                               ✓
Out(G) = Aut(G)/Inn(G)                                                          ✓
fast inverse                                                                    ✓
GL, PGL, PSL                                                                    ✓
automorphism from generators                                                    ✓
generalized symmetric group                                                     ✓
generalized quaternion group                                                    ✓
dicyclic group                                                                  ✓
central product                                                                 ✓
homomorphisms class                                                             ✓
subset/subgroup class                                                           ✓
isCyclic                                                                        ✓
Aut(G)                                                                          ✓
GL                                                                              ✓
PGL                                                                             ✓
Out(G)                                                                          ✓
commutator subgroup
wreath product
change the semidirect product f from array of automorphisms to an actual function
derived series
isSolvable
hyperoctahedral group
lower central series

quotient of group whose elements are lists cannot return cosets because lists are not hashable


metacyclic group

determinant function
SO,O

define group from generators and relations, for example G = < a,b,c,d | a3=b3=c3=d3=1, ab=ba, cac-1=ab-1, ad=da, bc=cb, bd=db, dcd-1=ab-1c > 

fast order for predefined groups
Write permutations as disjoint cycles (enumerate partitions of n etc), this could be useful for conjugacy classes
Change Symmetric.__lehmerinv and Alternating.__index from O(n^2) to O(n)
compute orders in O(n)
isIsomorphic (check cardinals, cyclic, abelian, element orders conjugacy classes,...)
isSimple

Aut(G) (as subgroup of Sn)
Aut, Inn, Out of direct, semidirect, central products, quotient group,...
Sylow subgroups, normal subgroups, subgroups
lattice of subgroups
get set of generators
reduce set of generators on Group.subgroup()
composition series
quotient group: is abelian / is cyclic / simple


character table

optimize Units()

simple groups
sporadic groups

Groups that don't work yet:
    Subgroup
    SL, PSL
    Aut2
    Holomorph: needs Aut2


Duplicated methods/classes:

centralizer2 >?? centralizer
Units2 > Units
"""

class Group:
    def __init__(self, n, e, op):
        self.element = e
        self.op = op
        self.card = n
        self.abelian = None
        self.cyclic = None
        self.simple = None
        self.id = None

    def __len__(self):
        return self.card

    def multiply(self, H, K):
        """
            HK = {h*k : h∈H, k∈K}
        """
        HK = set()
        for h in H:
            for k in K:
                HK.add(self.op(h, k))
        return HK

    def order(self, g):
        p = g
        order = 1
        while True:
            p = self.op(p, g)
            if p == g:
                return order
            order += 1

    def exponent(self):
        """
            lcm of all orders
        """
        return lcm(list(self.orders(True).keys()))

    def subgroup(self, gens):
        """
            Returns subgroup generated by gens
        """
        H = {self.identity()}
        size = 0
        while len(H) != size:
            size = len(H)
            for g in gens:
                for h in list(H):
                    H.add(self.op(h,g))

        return H

    def powers(self, g):
        """
            <g> = {g^k : k∈N}
        """
        p = [g]
        while True:
            t = self.op(p[-1], g)
            if t == g:
                return p
            p.append(t)

    def identity(self):
        """
            Returns identity element
        """
        if self.id is None:
            self.id = self.powers(0)[-1]
        return self.id

    def automorphism(self, genimg):
        """
            Get automorphism defined by the images of the generators
            genimg = {g:f(g) for g in gens}
        """
        bijection = [self.identity()]*self.card

        H = {self.identity()}

        for g, f in genimg.items():
            bijection[g] = f

        while len(H) != self.card:
            for g in genimg.keys():
                for h in list(H):
                    p = self.op(h, g)
                    if p not in H:
                        bijection[p] = self.op(bijection[h], bijection[g])
                        H.add(p)

        return bijection

    def Syl(self, p):
        if not isprime(p):
            return None
        m = self.card
        k = 0

        while m % p == 0:
            m //= p
            k += 1

        order = {o for o in range(1, m+1, p) if m % o == 0}

        # if k == 0:
        # return None
        ##

##    def centralizerSet(self,S):
##        """
##            {g∈G : gs=sg ∀s∈S}
##        """
        

    def centralizer(self, s):
        """
            {g∈G : gs=sg}
        """
        if self.isAbelian():
            return {g for g in self}

        C = {self.identity(), s}

        H = {g for g in self}

        while len(H) > 0:
            g = H.pop()
            if self.op(g, s) == self.op(s, g):
                powers = self.powers(g)
                C.add(g)
                for p in powers:
                    if p not in H:
                        continue
                    H.remove(p)
                    C.add(p)

        return C

    def centralizer2(self, s):
        return {g for g in self if self.op(g, s) == self.op(s, g)}

    def normalizer(self, H):
        if self.isAbelian():
            return {g for g in self}
        return {g for g in self if self.leftcoset(H, g) == self.rightcoset(H, g)}

    def normalizer2(self, H):
        if self.isAbelian():
            return {g for g in self}

        N = set(H)

        for g in self:
            if g in N:
                continue
            if self.leftcoset(H, g) == self.rightcoset(H, g):
                powers = [g]
                p = self.op(g, g)
                while p not in N:
                    powers.append(p)
                    p = self.op(p, g)

                for n in list(N):
                    for m in powers:
                        N.add(self.op(n, m))
        return N

    def orders(self, Dict=False):
        o = {self.identity(): 1}
        elements = {g for g in self}

        while len(elements) > 0:
            g = elements.pop()
            powers = self.powers(g)
            orderg = len(powers)
            o[g] = orderg

            for i in range(len(powers)):
                if powers[i] in o:
                    continue
                o[powers[i]] = orderg//gcd(i, orderg)
                elements.remove(powers[i])
            
        if Dict:
            h = dict()
            for k, v in o.items():
                h.setdefault(v, set()).add(k)
            return h
        return [o[i] for i in self]

    def center(self):
        """
            Z(G) = {g∈G : gs=sg ∀s∈G}
        """
        if self.abelian:
            return {k for k in self}
        Z = {self.identity()}
        for g in self:
            if g in Z:
                continue
            b = False
            for s in self:
                if s in Z:
                    continue
                if self.op(s, g) != self.op(g, s):
                    b = True
                    break
            if b:
                continue
            powers = [g]
            while True:
                t = self.op(g, powers[-1])
                if t == self.identity() or t in Z:
                    break
                powers.append(t)
            for s in list(Z):
                for x in powers:
                    Z.add(self.op(x, s))

        return Z

    def derivedSubgroup(self):
        """
            Commutator subgroup
            [G,G] = {g-1h-1gh : g,h∈G}
        """
        return self.commutatorSub(self,self)

    def commutatorSub(self,H,K):
        """
            Commutator subgroup of subgroups H and K
            [H,K] = {h-1k-1hk : h∈H,k∈K}
        """
        from groups import Subgroup
        
        S = {self.identity()}
        for h in H:
            for k in K:
                S.add(self.commutator(h,k))
        return Subgroup(self,H=S)
            
    def derivedSeries(self):
        S = [self]
        from groups import Subgroup
        if self.isAbelian():
            if self.card > 1:
                return S + [Subgroup(self,H=[self.identity()])]
            else:
                return S
        while True:
            C = S[-1].derivedSubgroup()
            if len(C) == len(S[-1]):
                return S
            S.append(C)
    
    def lowerCentralSeries(self):
        S = [self]
        from groups import Subgroup
        if self.isAbelian():
            if self.card > 1:
                return S + [Subgroup(self,H=[self.identity()])]
            else:
                return S
        while True:
            C = self.commutatorSub(S[-1],self)
            if len(C) == len(S[-1]):
                return S
            S.append(C)

    def isSolvable(self):
        if self.card < 60:
            return True

        if all(p == 1 for p in factorint(self.card).values()): # Square free order => solvable
            return True
        
        return len(self.derivedSeries()[-1]) == 1

    def isPerfect(self):
        """
            [G,G] == G
        """
        return len(self.derivedSeries()) == 1

    def perfectCore(self):
        """
            Largest perfect subgroup. Limit of the derived series
        """
        return self.derivedSeries()[-1] 

    def nilpotencyClass(self):
        """
            length of the lower central series
        """
        return len(self.lowerCentralSeries())-1

    def isNilpotent(self):
        """
            Lower central series end in the trivial subgroup
        """
        if self.isPGroup():
            return True
        return len(self.lowerCentralSeries()[-1]) == 1

    def isPGroup(self):
        return len(factorint(self.card)) == 1
    
    def pow(self, g, i):
        """
            g^i
        """
        p = self.identity()
        while i > 0:
            if i & 1:
                p = self.op(p, g)
            g = self.op(g, g)
            i >>= 1
        return p

    def inverse(self, g):
        """
            g^-1
        """
        p = g
        while True:
            tmp = self.op(p, g)
            if tmp == self.identity():
                return p
            p = tmp

    def leftconjugate(self, g, x):
        """
            gxg-1
        """
        return reduce(self.op, [g, x, self.inverse(g)])

    def rightconjugate(self, g, x):
        """
            g-1xg
        """
        return reduce(self.op, [self.inverse(g), x, g])

    def commutator(self, g, h):
        """
            g-1h-1gh
        """
        return reduce(self.op, [self.inverse(self.op(h, g)), g, h])

    def leftcoset(self, H, g):
        """
            gH = {gh : h∈H}
        """
        return {self.op(g, h) for h in H}

    def rightcoset(self, H, g):
        """
            Hg = {hg : h∈H}
        """
        return {self.op(h, g) for h in H}

    def conjugacyClass(self, x):
        """
            Cl(x) = {g-1xg : g∈G}
        """
        return {self.leftconjugate(g, x) for g in self}

    def conjugacyClasses(self):
        Cl = []

        for i in self:
            b = False
            for C in Cl:
                if i in C:
                    b = True
                    continue
            if not b:
                Cl.append(self.conjugacyClass(i))
        return Cl

    def isSubgroup(self, H):
        if self.card % len(H) != 0:
            return False
        for h in H:
            for k in H:
                if self.op(h, k) not in H:
                    return False
        return True

    def isNormal(self, H):
        """
            Test if H is normal in G
            H = list/set with indices of elements of G
        """
        if not self.isSubgroup(H):
            return False
        if self.card == 2*len(H) or self.isAbelian():
            return True

        H = set(H)

        S = {self.identity()}

        for h in H:
            if h in S:
                continue
            for g in self:
                if not self.leftconjugate(g, h) in H:
                    return False
            powers = [h]
            while True:
                t = self.op(h, powers[-1])
                if t == self.identity() or t in S:
                    break
                powers.append(t)
            for s in list(S):
                for x in powers:
                    S.add(self.op(x, s))
        return True

    def isAbelian(self):
        """
            Returns true if G is abelian
        """
        if self.abelian != None:
            return self.abelian
        elif self.cyclic:
            self.abelian = True
            return True
        else:
            S = {self.identity()}
            for g in self:
                if g in S:
                    continue
                for s in S:
                    if self.op(s, g) != self.op(g, s):
                        self.abelian = False
                        return False
                powers = [g]
                while True:
                    t = self.op(g, powers[-1])
                    if t == self.identity() or t in S:
                        break
                    powers.append(t)

                for s in list(S):
                    for x in powers:
                        S.add(self.op(x, s))

            self.abelian = True
        return self.abelian

    def isCyclic(self):
        if self.cyclic == None:
            if isprime(self.card):
                self.cyclic = True
                self.abelian = True
                self.simple = True
                return True
            if not self.isAbelian():
                self.cyclic = False
                return False
            self.cyclic = self.card in self.orders(True)
            return self.cyclic
        return self.cyclic

    def isSimple(self):
        if self.simple != None:
            return self.simple

        decomp = factorint(self.card)

        if len(decomp) == 1 and list(decomp.values())[0] == 1: #isprime
            self.simple = True
            return True
        elif self.card%2==1 or len(decomp) <= 2: # Feit-Thompson and Burnside's Theorems
            self.simple = False
            return False

        if self.isSolvable():
            return False

        # TODO analize sylow subgroups

        return None

    def isIsomorphic(self, other):
        if repr(self) == repr(other):
            return True
        if self.card != other.card or (self.isAbelian() != other.isAbelian()) or (self.isCyclic() != other.isCyclic()):
            return False

        o1 = self.orders(True)
        o2 = other.orders(True)

        lo1 = {k:len(v) for k,v in o1}
        lo2 = {k:len(v) for k,v in o2}

        if lo1 != lo2:
            return False
        elif self.isAbelian() and other.isAbelian():
            return True

##        c1 = self.conjugacyClasses()
##        c2 = other.conjugacyClasses()
##
##        lc1 = {k:len(v) for k,v in c1}
##        lc2 = {k:len(v) for k,v in c2}
        
        # TODO

    def __iter__(self):
        return GroupIter(self)

    def __truediv__(self, N):
        from groups import Quotient
        return Quotient(self, N)

    def __mul__(self, H):
        from groups import Direct
        return Direct(self, H)

    def __pow__(self, n):
        from groups import Direct
        return Direct([self]*n)

    def __getitem__(self, i):
        return self.element(i)

    def __eq__(self, H):
        return self.isIsomorphic(H)

class GroupIter():
    def __init__(self, G):
        self.G = G
        self.index = 0

    def __next__(self):
        if self.index < self.G.card:
            g = self.index
            self.index += 1
            return g
        raise StopIteration()


def cayleyTable(self, truerepr=False):
    """
    truerepr        True prints element name
                    False prints element index
    """
    if truerepr:
        T = ([self[self.op(j, i)] for i in self]for j in self)
    else:
        T = ([self.op(j, i) for i in self]for j in self)

    for i in T:
        print(",".join(str(j) for j in i))


def functioninverse(f):
    g = [None]*len(f)
    for i in range(len(f)):
        g[f[i]] = i
    return g

def composition(f, g):
    """
    Returns g◦f
    """
    return list(itemgetter(*f)(g))

def testassocrand(H,n):
    for _ in range(n):
        a,b,c = (randint(0,H.card-1) for _ in range(3))
        if H.op(H.op(a,b),c) != H.op(a,H.op(b,c)):
            print("Non associative",a,b,c)
            print(H.op(H.op(a,b),c), H.op(a,H.op(b,c)))
            return False
    return True

def count_partitions(n: int) -> int:
    if n < 0:
        return 0
    if n < 2:
        return 1
    
    dp = [0] * (n + 1)
    dp[0] = 1

    for i in range(1, n):
        for j in range(1, n + 1):
            if i <= j:
                dp[j] += dp[j - i]
    
    return dp[-1]+1

def count_abelian_groups(n):
    if n < 1:
        return 0
    if n < 4:
        return 1
    
    f = factorint(n)
    
    count = {}
    for i in f.values():
        count[i] = count.get(i, 0) + 1

    return reduce(lambda a,b: a*b, (count_partitions(k)**v for k,v in count.items()))

def count_groups(order):
    if order <= 0:
        return 0
    if order < 4:
        return 1
    f = factorint(order)

    l = list(f.items())
    l.sort(key=itemgetter(0))
    
    if len(l) == 1: # p-group
        prime,power = l[0]
        if power <= 2:
            return power
        if power == 3:
            return 5
        if power == 4:
            return 14 if prime == 2 else 15
        if power == 5:
            if prime == 2:
                return 51
            if prime == 3:
                return 67
            return 61 + 2*prime + 2*gcd(prime-1,3) + gcd(prime-1,4)
        return prime**((2/27)*(power**3))               # approximate
    if len(l) == 2:
        a,b = l[0][1],l[1][1] # exponents
        if a==b==1:           # pq
            return 1 if gcd(l[0][0],l[1][0]-1) == 1 else 2
        if {a,b} == {1,2}:          #pq^2
            p,q = l[0][0],l[1][0]
            if a == 2:
                p,q=q,p
            
            if p==2 and q&1:
                return 5
            if (q-1)%p == 0 and p&1:
                return (p+9)//2
            if p==3 and q==2:
                return 5
            if (q+1)%p == 0 and (p*q) & 1:
                return 3
            if (p-1)%(q**2)==0:        # maybe move down
                return 5
            if (p-1)%q == 0 and p>3: # and (p-1)%(q**2) != 0
                return 4
            return 2 # q != +-1 mod p and (p-1)%q
        return "todo"
    if len(l) == 3:
        if all(l[i][1] == 1 for i in range(3)): # square free order
            p,q,r = (l[i][0] for i in range(3))
            t = ((q-1)%p == 0)*4 + ((r-1)%p == 0)*2 + ((r-1)%q == 0)

            return [1,2,2,4,2,3,p+2,p+4][t]
            
        return "todo"
    if all(p == 1 for p in f.values()):     # aquare free order
        from itertools import product
        primes = set(f.keys())

        def c(p,primes):
            count = 0

            for q in primes:
                if (q-1)%p == 0:
                    count += 1
            return count
        
        count = 0
        for comb in product(*[[0,1]]*len(primes)): # combinations of all primes to compute divisors
            leftprimes = {p for i,p in enumerate(primes) if comb[i]}
            m = reduce(lambda a,b:a*b,leftprimes,1)
            
            prod = 1
            for p in primes-leftprimes:
                prod *= ((p**c(p,leftprimes)-1)/(p-1))

            count += prod
        
        return count
    return "todo"



class Subset():
    def __init__(self, G, H):
        e = list(H)
        self.element = lambda k: e[k]
        self.card = len(H)
        # This returns an element of G that cannot be converted back to an element of H since we don't know of H is closed under the operation of G
        self.op = lambda g, h: G.op(self.element(g), self.element(h))
        self.subgroup = None

if __name__ == "__main__":
    from groups import *
    from testraster import saveImage

##    G = Cyclic(2)**3
##    A = Aut2(G)
##    A.generators = {128,129,130}
##    AA = Aut2(A)
    
